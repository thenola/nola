## План развития ядра Nola

Этот файл описывает порядок работ. Новые фичи добавляем как отдельные шаги и
по очереди реализуем их в коде.

### Этап 0 — Базовая загрузка (выполнено)

- Загрузка через GRUB2 / Multiboot2.
- Переход в long mode, базовая GDT, простая страничная таблица.
- Ядро на C, вывод в текстовый VGA, простая IDT и заглушка обработчика.

### Этап 1 — Интеграция с Multiboot2 (выполнено)

1. Передать в `kernel_main` параметры Multiboot2:
   - magic (`eax`),
   - адрес структуры multiboot2 info (`ebx`).
2. В `kernel_main` вывести на экран:
   - значение magic,
   - адрес структуры multiboot2 info,
   чтобы убедиться, что данные пришли корректно.
3. Подготовить хедер `multiboot2.h` и каркас парсера тегов (memory map и др.)
   для дальнейших этапов. (готово: `multiboot2.h/.c`, выводим карту памяти)

### Этап 2 — Карта памяти и фрейм‑аллокатор (выполнено)

- Реализовать парсер карты памяти (Mmap tag) из Multiboot2. (готово в `multiboot2.c` и `paging.c`)
- Построить битовую карту/структуру свободных физических страниц. (готово в `paging.c`)
- Реализовать `alloc_frame` поверх реальной карты памяти (используется через `alloc_page`). (готово)
- Реализовать `free_frame` через `free_page`. (готово)

### Этап 3 — Улучшенный paging и high‑half kernel (частично выполнено)

- Определить схему виртуальных адресов ядра (high‑half). (готово: `KERNEL_VIRT_BASE = 0xFFFF800000000000`)
- Перестроить таблицы страниц так, чтобы ядро жило в высоких адресах. (готово: `paging_vmm.c` настраивает mapping)
- Обновить все обращения к памяти (стек, данные, heap). (частично: mapping настроен, но полное переключение на высокие адреса требует обновления всех указателей и RSP - можно сделать позже)

### Этап 4 — Полноценные прерывания и исключения (выполнено)

- ASM‑стабы для всех исключений (0-31) и IRQ (32-47) в `isr.asm`. (готово)
- Расширенный вывод информации об исключениях (номер, код, RIP, регистры) в `idt.c`. (готово)
- Инициализация PIC, переназначение IRQ на вектора 32-47 в `pic.c`. (готово)
- Прерывания включены (`sti`) после инициализации. (готово)

### Этап 5 — Таймер и планирование

- Инициализировать PIT/APIC timer, завести тик‑счётчик.
- Базовое планирование: простой “tick handler”, возможно, задел под треды.

### Этап 6 — Клавиатура и ввод

- Обработчик IRQ клавиатуры, очередь нажатий.
- Интеграция с консолью: ввод строк с клавиатуры.

### Этап 7 — Kernel heap и базовые сервисы

- Реализовать `kmalloc`/`kfree` поверх фрейм‑аллокатора.
- Выделение памяти под внутренние структуры ядра (таблицы, буферы и т.п.).

