## План развития ядра Nola

Этот файл описывает порядок работ. Новые фичи добавляем как отдельные шаги и
по очереди реализуем их в коде.

### Этап 0 — Базовая загрузка (выполнено)

- Загрузка через GRUB2 / Multiboot2.
- Переход в long mode, базовая GDT, простая страничная таблица.
- Ядро на C, вывод в текстовый VGA, простая IDT и заглушка обработчика.

### Этап 1 — Интеграция с Multiboot2 (выполнено)

1. Передать в `kernel_main` параметры Multiboot2:
   - magic (`eax`),
   - адрес структуры multiboot2 info (`ebx`).
2. В `kernel_main` вывести на экран:
   - значение magic,
   - адрес структуры multiboot2 info,
   чтобы убедиться, что данные пришли корректно.
3. Подготовить хедер `multiboot2.h` и каркас парсера тегов (memory map и др.)
   для дальнейших этапов. (готово: `multiboot2.h/.c`, выводим карту памяти)

### Этап 2 — Карта памяти и фрейм‑аллокатор (частично выполнено)

- Реализовать парсер карты памяти (Mmap tag) из Multiboot2. (готово в `multiboot2.c` и `paging.c`)
- Построить битовую карту/структуру свободных физических страниц. (готово в `paging.c`)
- Реализовать `alloc_frame` поверх реальной карты памяти (используется через `alloc_page`).  
- `free_frame` пока не реализован, будет добавлен позже при появлении реального heap/OS.

### Этап 3 — Улучшенный paging и high‑half kernel

- Определить схему виртуальных адресов ядра (high‑half).
- Перестроить таблицы страниц так, чтобы ядро жило в высоких адресах.
- Обновить все обращения к памяти (стек, данные, heap).

### Этап 4 — Полноценные прерывания и исключения

- ASM‑стабы для всех исключений и IRQ.
- Расширенный вывод информации об исключениях (номер, код, RIP, регистры).
- Инициализация PIC/APIC, настройка масок IRQ.

### Этап 5 — Таймер и планирование

- Инициализировать PIT/APIC timer, завести тик‑счётчик.
- Базовое планирование: простой “tick handler”, возможно, задел под треды.

### Этап 6 — Клавиатура и ввод

- Обработчик IRQ клавиатуры, очередь нажатий.
- Интеграция с консолью: ввод строк с клавиатуры.

### Этап 7 — Kernel heap и базовые сервисы

- Реализовать `kmalloc`/`kfree` поверх фрейм‑аллокатора.
- Выделение памяти под внутренние структуры ядра (таблицы, буферы и т.п.).

